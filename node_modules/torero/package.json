{
  "name": "torero",
  "description": "an MVC framework for Node that I'm going to maintain.",
  "version": "0.0.7-alpha",
  "homepage": "http://byrdhou.se/torero",
  "main": "src/torero.js",
  "authors": [
    "Dustin Diaz <dustin@obvious.com> (https://github.com/ded)",
    "Dustin Senos <ds@obvious.com> (https://github.com/dustinsenos)",
    "Jeremy Stanley <jeremy@obvious.com> (https://github.com/azulus)",
    "Rael Dornfest <rael@obvious.com> (https://github.com/raelity)",
    "David Byrd <david@byrdhou.se> (https://github.com/davidbyrd11)"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/davidbyrd11/torero.git"
  },
  "engines": {
    "node": ">=0.8.8 <0.9"
  },
  "bin": {
    "torero": "bin/torero.js"
  },
  "dependencies": {
    "connect": "2.3.3",
    "valentine": "*",
    "klass": "*",
    "colors": "*",
    "hogan.js": "*",
    "optimist": "*",
    "uglify-js": ">=1.2.5",
    "soynode": ">=0.1.3",
    "less-middleware": "~0.1.7"
  },
  "devDependencies": {
    "jshint": "0.5.8"
  },
  "scripts": {
    "lint": "node_modules/jshint/bin/hint src/ --reporter dev/reporter.js"
  },
  "readme": "# Torero\nIts still in progress, but the gist is that Obvious Corporation made an awesome simple MVC framework called Matador. I&#8217;m trying build an eCommerce platform on top of it.\n\nTorero is a simple MVC framework for node.js that&#8217;s built on top of Matador. It&#8217;s made with the promise that I will actually maintain it.\n\nTorero is a clean, organized framework for [Node.js](http://nodejs.org) architected to suit MVC enthusiasts. It gives you a well-defined development environment with flexible routing, easy controller mappings, and basic request filtering.\nIt&#8217;s built on open source libraries such as [Hogan.js](http://twitter.github.com/hogan.js) for view rendering, [Klass](https://github.com/ded/klass) for its inheritance model, [Valentine](https://github.com/ded/valentine)\nfor functional development, and [Connect](http://www.senchalabs.org/connect/) to give a bundle of other Node server related helpers.\n\n# Installation\n### Get the CLI\n    $ npm install torero -g\n\n### Create an app\n    $ torero create app-name\n    $ cd !$ && npm install torero\n\n### Start your app\n    $ node server\n\n# Dancing with the Bulls\n### Build on your app\n\n``` js\n// app/config/routes.js\n'/hello/:name': { 'get': 'Home.hello' }\n\n// app/controllers/HomeController.js\nmodule.exports = function(app, config) {\n  return app.getController(\"Home\", true).extend()\n  .methods({\n    hello: function (request, response, name) {\n      this.render(response, 'hello', {\n        name: name\n      })\n    }\n  });\n  \n}\n```\nEach controller is a module that takes the app and a config object as its parameters.\n\nThe first argument of the getController method is the name of the controller so that Torero can keep track of references to it.\n\nThe second argument of the getController method is true when you want it to return a constructor function and false when you want it to return an instance of that klass.TODO (look into klass and figure this out for suresa=)\n\n### View Rendering\nUses Twitter's [Hogan.js](http://twitter.github.com/hogan.js/) with layouts, partials, and i18n support.\n\n``` js\n// app/controllers/HomeController.js\nthis.render(response, 'hello', {\n  name: name\n})\n```\nwe're calling render on this (the controller klass) because all controllers are sub classes of the BaseController which includes the render function. \n\nthe first parameter of render is the response variable as the first parameter and the template name as the second parameter and the data you want to pass to the template is the third parameter.\n\n\n``` html\n<!-- app/views/layout.html -->\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta http-equiv=\"Content-type\" content=\"text/html; charset=utf-8\">\n    <title>hello {{name}}</title>\n  </head>\n  <body>\n    {{{body}}}\n  </body>\n</html>\n```\n\n``` html\n<!-- app/views/hello.html -->\n<h1>{{name}}</h1>\n```\n\n### View Partials\n\n**To Be Updated**\n\nMatador looks for view partials in a folder named partials in the views directory: ```app/views/partials/```\n\n``` js\n// app/controllers/HomeController.js\nmodule.exports = function (app, config) {\n  return app.controllers.Base.extend()\n  .methods({\n    index: function (req, res) {\n      this.render(res, 'index', {\n          user: {\n              first: \"John\"\n            , last: \"Smith\"\n          }\n        , todo: [{ name: 'dishes', id: 0 }, { name: 'mow lawn', id: 1 }]\n      })\n    }\n  })\n}\n```\n\n```html\n<!-- app/views/partials/fullname.html -->\n{{first}} {{last}}\n```\n\n```html\n<!-- app/views/partials/tasks.html -->\n<ul>\n  {{#todo}}\n  <li>{{name}}</li>\n  {{/todo}}\n</ul>\n```\n\n```html\n<!-- app/views/index.html -->\n<h1>Hello {{#user}}{{> fullname}}{{/user}} welcome to Matador!</h1>\n{{> tasks}}\n```\n\nProduces the following HTML:\n\n```html\n<h1>Hello John Smith welcome to Matador!</h1>\n<ul>\n  <li>dishes</li>\n  <li>mow lawn</li>\n</ul>\n```\n\n### Overriding View Partials\n\nMatador allows you to easily override view partials on a per-directory basis.\nTo override a partial create a new folder named 'partials' in the folder your controller is using as its ```viewFolder```.\nMatador will look first in this folder for partials, if no matching partial exists it will traverse up the directory tree until it finds a matching partial.\n\n``` js\n// app/controllers/admin/AdminController.js\nmodule.exports = function (app, config) {\n  return app.getController('Application', true).extend(function () {\n    this.viewFolder = \"admin\" // we've set the view folder to \"admin\"\n  })\n  .methods({\n    index: function (req, res) {\n      this.render(res, 'index', {\n          user: {\n              first: \"John\"\n            , last: \"Smith\"\n          }\n        , todo: [{ name: 'dishes', id: 0 }, { name: 'mow lawn', id: 1 }]\n      })\n    }\n  })\n}\n```\n\n```html\n<!-- app/views/admin/partials/tasks.html -->\n<!-- This file will override the tasks.html partial found in app/views/partials -->\n<ul>\n{{#todo}}\n<li><a href=\"/edit/{{id}}\">Edit the \"{{name}}\" task </a> or <a href=\"/delete/{{id}}\">delete it</a></li>\n{{/todo}}\n</ul>\n```\n\n```html\n<!-- app/views/admin/index.html -->\n<!-- 'app/views/admin/partials/fullname.html' Does not exist, so 'app/views/partials/fullname.html' will be used -->\n<h1>Welcome {{#user}}{{> fullname}}{{/user}} to the Admin Area</h1>\n{{> tasks}}\n```\n\nProduces the following HTML:\n\n```html\n<h1>Welcome John Smith to the Admin Area</h1>\n<ul>\n  <li><a href=\"/edit/0\">Edit the \"dishes\" task</a> or <a href=\"/delete/0\">delete it</a></li>\n  <li><a href=\"/edit/1\">Edit the \"mow lawn\" task</a> or <a href=\"/delete/1\">delete it</a></li>\n</ul>\n```\n\n**Note:** For performance reasons, partials are fetched when the application starts. You must restart your application for changes in partials to be reflected.\n\n### Request Filtering\n``` js\n// app/controllers/ApplicationController.js\nmodule.exports = function (app, config) {\n  return app.controllers.Base.extend(function () {\n    this.addBeforeFilter(this.requireAuth)\n    this.addExcludeFilter(['welcome'], this.requireAuth)\n  })\n  .methods({\n    requireAuth: function (callback) {\n      if (this.request.cookies.authed) return callback(null)\n      this.response.redirect('/welcome')\n    }\n  , welcome: function () {\n      this.render('welcome')\n    }\n  })\n}\n```\n\n### Routing\nThe `app/config/routes.js` file is where you specify an array of tuples indicating where incoming requests will map to a `controller` and the appropriate method. If no action is specified, it defaults to 'index' as illustrated below:\n\n``` js\nmodule.exports = function (app) {\n  return {\n    '/': 'Home' // maps to ./HomeController.js => index\n  , '/admin': 'Admin.show' // maps to ./admin/AdminController.js => show\n  }\n}\n```\n\n### How can I organize my Models?\nBy default, Models are thin with just a Base and Application Model in place. You can give them some meat, for example, and embed [Mongo](http://mongoosejs.com) Schemas. See the following as a brief illustration:\n\n``` js\n// app/models/ApplicationModel.js\nmodule.exports = function (app, config) {\n  return app.getModel('Base', true).extend(function () {\n    this.mongoose = require('mongoose');\n    this.Schema = this.mongoose.Schema;\n    this.db = this.mongoose.createConnection('mongodb://localhost:27017/' + config.dbname);\n  });\n};\n```\n\nThen create, for example, a UserModel.js that extended it...\n\n``` js\nmodule.exports = function (app, config) {\n  return app.getModel('Application', true).extend(function () {\n    this.DBModel = this.db.model('User', new this.Schema({\n        name: { type: String, required: true, trim: true }\n      , email: { type: String, required: true, lowercase: true, trim: true }\n    }))\n  })\n  .methods({\n    create: function (name, email, callback) {\n      var user = new this.DBModel({\n          name: name\n        , email: email\n      })\n      user.save(callback)\n    }\n  , find: function (id, callback) {\n      this.DBModel.findById(id, callback)\n    }\n  })\n}\n```\n\nThis provides a proper abstraction between controller logic and how your models interact with a database then return data back to controllers.\n\nTake special note that models do not have access to requests or responses, as they rightfully shouldn't.\n\n### Model & Controller Inheritance\nThe inheritance model Matador uses is built with [Klass](https://github.com/ded/klass), and is exposed via a global `Class` variable (not all globals are bad). Class comes in two flavors where by constructors can be set via an `initialize` method, or a function reference, and by default (in the scaffold), Matador uses the function reference style so that you may benefit from the auto-initialization of super classes, and there is no need to call `this.supr()` in your constructors.\n\n### Valentine\nThe Valentine module is included as a simple tool giving you type checking, functional iterators, and some other nice utilities that often get used in applications of any size. It is exposed globally as `v`. It is used liberally in the Matador router, thus feel free to take advantage of its existence as well.\n\n# Scaffolding\n\n    $ torero controller [name]\n    $ torero model [name]\n\n# AWS Setup\nTorero is tightly integrated with Amazon Web Services. All of the images are uploaded to the S3 bucket and distributed by a cloudfront distribution that should both be specified in config/production.js. You will also need to fill in your AWS key and secret. \n\n# Contributing & Development\n\nQuestions, pull requests, bug reports are all welcome. Submit them here on Github.\nWhen submitting pull requests, please run through the linter to conform to the framework style\n\n    $ npm install -d\n    $ npm run-script lint\n\n# Matador Authors\n[Dustin Senos](https://github.com/dustinsenos), [Dustin Diaz](https://github.com/ded)\n\n\n# Matador License\nCopyright 2012 [Obvious Corporation](http://obvious.com)\n\nLicensed under the Apache License, Version 2.0: http://www.apache.org/licenses/LICENSE-2.0",
  "_id": "torero@0.0.7-alpha",
  "_from": "torero@*"
}
